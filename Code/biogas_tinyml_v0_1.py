# -*- coding: utf-8 -*-
"""biogas_tinyml_v0.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GgjMTDlx1phaEOQF6Ci1XRK-GiFXkCur
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, TimeSeriesSplit
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt
import seaborn as sns
import joblib

path = "/content/biogas_rtdb.csv"
df = pd.read_csv(path);

df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
df['timestamp'] = df['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')


df.head()

def missing_vals(df):
    """prints out columns with perc of missing values"""
    missing = [
        (df.columns[idx], perc)
        for idx, perc in enumerate(df.isna().mean() * 100)
        if perc > 0
    ]

    if len(missing) == 0:
        return "no missing values"


    # sort desc by perc
    missing.sort(key=lambda x: x[1], reverse=True)

    print(f"There are a total of {len(missing)} variables with missing values\n")

    for tup in missing:
        print(str.ljust(f"{tup[0]:<20} => {round(tup[1], 3)}%", 1))

missing_vals(df)

df = df.dropna()
missing_vals(df)

df['pressure_pa'] = df['pressure'] * 1000
df['ch4_ppm'] = df['ch4']
df['co2_ppm'] = df['co2']
df['h2s_ppm'] = df['h2s']

df['ch4_frac'] = df['ch4_ppm'] / 10000000
df['co2_frac'] = df['co2_ppm'] / 10000000
df['h2s_frac'] = df['h2s_ppm'] / 10000000

df['timestamp'] = pd.to_datetime(df['timestamp'])

df["pressure_pa_smooth"] = df["pressure_pa"].rolling(5, min_periods=1).mean()
df["deltaP_pa"] = df["pressure_pa_smooth"].clip(lower=0)
df["delta_t_s"] = df["timestamp"].diff().dt.total_seconds().fillna(60)
df["delta_t_s"] = df["delta_t_s"].clip(lower=1)
df.head()

HEADSPACE_M3 = 82.5
P0_KPA = 101.0
P0_PA = P0_KPA * 1000

df['deltaV_m3'] = HEADSPACE_M3 * df['deltaP_pa'] / P0_PA

df['V_ch4'] = df['deltaV_m3'] * df['ch4_frac']
df['V_co2'] = df['deltaV_m3'] * df['co2_frac']
df['V_h2s'] = df['deltaV_m3'] * df['h2s_frac']

df.head()

df.to_csv("biogas_rtdb_processed.csv", index = False)

df_p = pd.read_csv("biogas_rtdb_processed.csv")

plt.style.use("default")
plt.rcParams["figure.figsize"] = (10, 5)
sns.set(font_scale=1.1)

missing_vals(df_p)

df_p['timestamp'] = pd.to_datetime(df_p['timestamp'], errors='coerce')

df_p = df_p.sort_values("timestamp").reset_index(drop=True)

df_p.info()
df_p.shape

#Methane Interval Volume vs Time
plt.figure()
plt.plot(df_p['timestamp'], df_p['V_ch4'])
plt.xlabel('Time')
plt.ylabel('Methane')
plt.title('Methane Production Over Time')
plt.xticks(rotation = 30)
plt.tight_layout()
plt.show()

#Pressure vs Time
plt.figure()
plt.plot(df_p['timestamp'], df_p['deltaP_pa'])
plt.xlabel('Time')
plt.ylabel('Pressure')
plt.title('Pressure Over Time')
plt.xticks(rotation = 30)
plt.tight_layout()
plt.show()

main_features = ['temperature', 'humidity', "extTemp", "extHum", "pressure"]
print(df[main_features + ["V_ch4"]].describe().T)

num_cols = main_features + ["V_ch4"]

df_p[num_cols].hist(bins = 30, figsize=(12, 8))
plt.suptitle('Feature Distributions', y=1.02)
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 6))
df_p[num_cols].boxplot()
plt.title("Boxplot of features & target")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

f, ax = plt.subplots(figsize = (10, 10))
sns.heatmap(df_p[num_cols].corr(), annot = True, cmap = "coolwarm")

def correlation(dataset, threshold):
    col_corr = set()
    corr_matrix = dataset.corr()
    for i in range(len(corr_matrix.columns)):
        for j in range(i):
            if abs(corr_matrix.iloc[i, j]) > threshold:
                colname = corr_matrix.columns[i]
                col_corr.add(colname)
    return col_corr

df_p['hour'] = df_p['timestamp'].dt.hour
df_p['dayofweek'] = df_p['timestamp'].dt.dayofweek
df_p['hour_sin'] = np.sin(df_p['hour'] * (2 * np.pi / 24))
df_p['hour_cos'] = np.cos(df_p['hour'] * (2 * np.pi / 24))

df_p['dow_sin'] = np.sin(df_p['dayofweek'] * (2 * np.pi / 7))
df_p['dow_cos'] = np.cos(df_p['dayofweek'] * (2 * np.pi / 7))

feature_cols = ['temperature', 'humidity', 'extTemp', 'extHum', 'pressure',
                'hour_sin', 'hour_cos', 'dow_sin', 'dow_cos']
target_col = 'V_ch4'

x = df_p[feature_cols]
y = df_p[target_col]
print(x)
print(y)
print(x.shape)
print(y.shape)

n = len(df_p)
train_size = int(n*0.8)

X_train, X_test = x.iloc[:train_size], x.iloc[train_size:]
y_train, y_test = y.iloc[:train_size], y.iloc[train_size:]

X_train.shape, X_test.shape, y_train.shape, y_test.shape

def evaluate_regression(model_name, y_true, y_pred):
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(y_true, y_pred)
    r2 = r2_score(y_true, y_pred)
    print(f"--- {model_name} ---")
    print(f"MSE : {mse:.10f}")
    print(f"RMSE: {rmse:.6f}")
    print(f"MAE : {mae:.6f}")
    print(f"R²  : {r2:.4f}")
    print()
    return {"mse": mse, "rmse": rmse, "mae": mae, "r2": r2}

lin_pipe = Pipeline(steps=[
    ("scaler", StandardScaler()),
    ("model", LinearRegression())
])

lin_pipe.fit(X_train, y_train)
y_pred_lin = lin_pipe.predict(X_test)

metrics_lin = evaluate_regression("Linear Regression", y_test, y_pred_lin)

ridge_pipe = Pipeline(steps=[
    ("scaler", StandardScaler()),
    ("model", Ridge(alpha=1.0))
])

ridge_pipe.fit(X_train, y_train)
y_pred_ridge = ridge_pipe.predict(X_test)

metrics_ridge = evaluate_regression("Ridge Regression", y_test, y_pred_ridge)

rf_model = RandomForestRegressor(
    n_estimators=300,
    max_depth=None,
    min_samples_split=2,
    min_samples_leaf=1,
    n_jobs=-1,
    random_state=42
)

rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

metrics_rf = evaluate_regression("Random Forest", y_test, y_pred_rf)

best_pred = y_pred_rf  # choose whichever is best
residuals = y_test - best_pred

plt.figure()
plt.scatter(best_pred, residuals, alpha=0.5)
plt.axhline(0, linestyle="--")
plt.xlabel("Predicted V_ch4")
plt.ylabel("Residuals")
plt.title("Residuals vs Predicted (Random Forest)")
plt.tight_layout()
plt.show()

# Ensure timestamp sorted
df_p = df_p.sort_values("timestamp").reset_index(drop=True)

# Time difference between samples
df_p['dt'] = df_p['timestamp'].diff().dt.total_seconds()

# Define continuity threshold (e.g., max 120 sec gap allowed)
CONTINUITY_THRESHOLD = 120

# Mark new segments where gap is too large
df_p['segment'] = (df_p['dt'] > CONTINUITY_THRESHOLD).cumsum()

# Find the longest continuous segment
segment_lengths = df_p.groupby('segment').size()
best_segment = segment_lengths.idxmax()

df_seg = df_p[df_p['segment'] == best_segment].copy()

df_seg['V_ch4_smooth'] = df_seg['V_ch4'].rolling(
    window=15, min_periods=1, center=True
).mean()

df_seg['pressure_smooth'] = df_seg['pressure'].rolling(
    window=15, min_periods=1, center=True
).mean()

plt.style.use("seaborn-v0_8-whitegrid")

fig, ax1 = plt.subplots(figsize=(12, 5))

# CH₄
ax1.plot(
    df_seg['timestamp'],
    df_seg['V_ch4_smooth'],
    color='#1B5E20',
    linewidth=2.5,
    label='CH₄ Production Rate'
)
ax1.set_ylabel('CH₄ Production Rate (m³/h)', color='#1B5E20')
ax1.tick_params(axis='y', labelcolor='#1B5E20')

# Pressure (secondary axis)
ax2 = ax1.twinx()
ax2.plot(
    df_seg['timestamp'],
    df_seg['pressure_smooth'],
    color='#B71C1C',
    linewidth=2,
    alpha=0.85,
    label='Digester Pressure'
)
ax2.set_ylabel('Pressure (kPa)', color='#B71C1C')
ax2.tick_params(axis='y', labelcolor='#B71C1C')

# Title
ax1.set_title(
    "Temporal Dynamics of Methane Production and Digester Pressure",
    fontsize=14,
    pad=10
)

# Legend
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left')

fig.autofmt_xdate()
plt.tight_layout()
plt.savefig(
    "CH4_Pressure_Temporal_Relationship.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

plt.savefig(
    "CH4_Pressure_Temporal_Relationship.png",
    dpi=600,
    bbox_inches="tight",
    format="png"
)

import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(
    style="whitegrid",
    font_scale=1.05,
    rc={
        "axes.titlesize": 11,
        "axes.labelsize": 10,
        "xtick.labelsize": 9,
        "ytick.labelsize": 9
    }
)

features = [
    ('temperature', 'Internal Temperature (°C)'),
    ('humidity', 'Internal Humidity (%)'),
    ('extTemp', 'External Temperature (°C)'),
    ('extHum', 'External Humidity (%)'),
    ('pressure', 'Pressure (kPa)'),
    ('V_ch4', 'CH₄ Production Rate (m³/h)')
]

palette = ["#4C72B0", "#55A868", "#C44E52",
           "#8172B2", "#CCB974", "#64B5CD"]

fig, axes = plt.subplots(2, 3, figsize=(15, 7))
axes = axes.flatten()

for ax, (col, label), color in zip(axes, features, palette):

    # Violin plot (distribution)
    sns.violinplot(
        y=df_p[col],
        ax=ax,
        inner=None,
        linewidth=1,
        color=color,
        cut=0,
        density_norm="width", # Changed 'scale="width"' to 'density_norm="width"'
        alpha=0.75
    )

    # Box plot overlay (statistics)
    sns.boxplot(
        y=df_p[col],
        ax=ax,
        width=0.02,
        showcaps=True,
        boxprops={"facecolor": "black", "zorder": 2},
        whiskerprops={"linewidth": 1.2},
        medianprops={"color": "white", "linewidth": 2},
        showfliers=False
    )

    ax.set_title(label, pad=6)
    ax.set_xlabel("")
    ax.set_ylabel("")
    ax.grid(axis="y", linestyle="--", alpha=0.4)

plt.suptitle(
    "Statistical Distribution of Sensor Parameters and Methane Production",
    fontsize=15,
    y=1.03
)

plt.tight_layout()
plt.show()

features = [
    ('temperature', 'Temperature (°C)'),
    ('humidity', 'Humidity (%)'),
    ('extTemp', 'External Temperature (°C)'),
    ('extHum', 'External Humidity (%)'),
    ('pressure', 'Pressure (kPa)'),
    ('V_ch4', 'CH₄ Production Rate (m³/h)')
]

fig, axes = plt.subplots(3, 2, figsize=(12,8))
axes = axes.flatten()

for ax, (col, label) in zip(axes, features):
    sns.kdeplot(
        df_p[col],
        ax=ax,
        fill=True,
        linewidth=2,
        color="#4C72B0"
    )
    ax.set_title(label)
    ax.set_xlabel(label)
    ax.set_ylabel("Density")
    sns.despine(ax=ax)

plt.suptitle("Kernel Density Distribution of Key Parameters", fontsize=14)
plt.tight_layout()
plt.savefig(
    "Kernel Density Distribution of Key Parameters.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(
    style="ticks",
    font_scale=1.1
)

col = 'V_ch4'
label = 'CH₄ Production Rate (m³/h)'

plt.figure(figsize=(5.5, 4))

# Violin (distribution)
sns.violinplot(
    y=df_p[col],
    inner=None,
    linewidth=1.2,
    color="#64B5CD",
    cut=0,
    density_norm="width",
    alpha=0.85
)

# Boxplot (statistics)
sns.boxplot(
    y=df_p[col],
    width=0.015,
    showcaps=True,
    boxprops=dict(facecolor="#2F2F2F", edgecolor="black"),
    whiskerprops=dict(color="black"),
    medianprops=dict(color="white", linewidth=2),
    showfliers=False
)

plt.ylabel(label)
plt.xlabel("")
plt.title(f"Statistical Distribution of {label}", pad=8)

sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.savefig(
    "Statistical_Distribution_of_CH4_Production_Rate.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

# ('temperature', 'Internal Temperature (°C)'),
#     ('humidity', 'Internal Humidity (%)'),
#     ('extTemp', 'External Temperature (°C)'),
#     ('extHum', 'External Humidity (%)'),
#     ('pressure', 'Pressure (kPa)'),
#     ('V_ch4', 'CH₄ Production Rate (m³/h)')
# palette = ["#4C72B0", "#55A868", "#C44E52",
#            "#8172B2", "#CCB974", "#64B5CD"]
sns.set_theme(
    style="ticks",
    font_scale=1.1
)

col = 'temperature'
label = 'Internal Temperature (°C)'

plt.figure(figsize=(5.5, 4))

# Violin (distribution)
sns.violinplot(
    y=df_p[col],
    inner=None,
    linewidth=1.2,
    color="#4C72B0",
    cut=0,
    density_norm="width",
    alpha=0.85
)

# Boxplot (statistics)
sns.boxplot(
    y=df_p[col],
    width=0.015,
    showcaps=True,
    boxprops=dict(facecolor="#2F2F2F", edgecolor="black"),
    whiskerprops=dict(color="black"),
    medianprops=dict(color="white", linewidth=2),
    showfliers=False
)

plt.ylabel(label)
plt.xlabel("")
plt.title(f"Statistical Distribution of {label}", pad=8)

sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.savefig(
    "Statistical_Distribution_of_Internal_Temperature.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

# ('temperature', 'Internal Temperature (°C)'),
#     ('humidity', 'Internal Humidity (%)'),
#     ('extTemp', 'External Temperature (°C)'),
#     ('extHum', 'External Humidity (%)'),
#     ('pressure', 'Pressure (kPa)'),
#     ('V_ch4', 'CH₄ Production Rate (m³/h)')
# palette = ["#4C72B0", "#55A868", "#C44E52",
#            "#8172B2", "#CCB974", "#64B5CD"]
sns.set_theme(
    style="ticks",
    font_scale=1.1
)

col = 'humidity'
label = 'Internal Humidity (%)'

plt.figure(figsize=(5.5, 4))

# Violin (distribution)
sns.violinplot(
    y=df_p[col],
    inner=None,
    linewidth=1.2,
    color="#55A868",
    cut=0,
    density_norm="width",
    alpha=0.85
)

# Boxplot (statistics)
sns.boxplot(
    y=df_p[col],
    width=0.015,
    showcaps=True,
    boxprops=dict(facecolor="#2F2F2F", edgecolor="black"),
    whiskerprops=dict(color="black"),
    medianprops=dict(color="white", linewidth=2),
    showfliers=False
)

plt.ylabel(label)
plt.xlabel("")
plt.title(f"Statistical Distribution of {label}", pad=8)

sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.savefig(
    "Statistical_Distribution_of_Internal_Humidity.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

# ('temperature', 'Internal Temperature (°C)'),
#     ('humidity', 'Internal Humidity (%)'),
#     ('extTemp', 'External Temperature (°C)'),
#     ('extHum', 'External Humidity (%)'),
#     ('pressure', 'Pressure (kPa)'),
#     ('V_ch4', 'CH₄ Production Rate (m³/h)')
# palette = ["#4C72B0", "#55A868", "#C44E52",
#            "#8172B2", "#CCB974", "#64B5CD"]
sns.set_theme(
    style="ticks",
    font_scale=1.1
)

col = 'extTemp'
label = 'Internal External Temperature (°C)'

plt.figure(figsize=(5.5, 4))

# Violin (distribution)
sns.violinplot(
    y=df_p[col],
    inner=None,
    linewidth=1.2,
    color="#C44E52",
    cut=0,
    density_norm="width",
    alpha=0.85
)

# Boxplot (statistics)
sns.boxplot(
    y=df_p[col],
    width=0.015,
    showcaps=True,
    boxprops=dict(facecolor="#2F2F2F", edgecolor="black"),
    whiskerprops=dict(color="black"),
    medianprops=dict(color="white", linewidth=2),
    showfliers=False
)

plt.ylabel(label)
plt.xlabel("")
plt.title(f"Statistical Distribution of {label}", pad=8)

sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.savefig(
    "Statistical_Distribution_of_External Temperature.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

# ('temperature', 'Internal Temperature (°C)'),
#     ('humidity', 'Internal Humidity (%)'),
#     ('extTemp', 'External Temperature (°C)'),
#     ('extHum', 'External Humidity (%)'),
#     ('pressure', 'Pressure (kPa)'),
#     ('V_ch4', 'CH₄ Production Rate (m³/h)')
# palette = ["#4C72B0", "#55A868", "#C44E52",
#            "#8172B2", "#CCB974", "#64B5CD"]
sns.set_theme(
    style="ticks",
    font_scale=1.1
)

col = 'extHum'
label = 'Internal External Humidity (%)'

plt.figure(figsize=(5.5, 4))

# Violin (distribution)
sns.violinplot(
    y=df_p[col],
    inner=None,
    linewidth=1.2,
    color="#8172B2",
    cut=0,
    density_norm="width",
    alpha=0.85
)

# Boxplot (statistics)
sns.boxplot(
    y=df_p[col],
    width=0.015,
    showcaps=True,
    boxprops=dict(facecolor="#2F2F2F", edgecolor="black"),
    whiskerprops=dict(color="black"),
    medianprops=dict(color="white", linewidth=2),
    showfliers=False
)

plt.ylabel(label)
plt.xlabel("")
plt.title(f"Statistical Distribution of {label}", pad=8)

sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.savefig(
    "Statistical_Distribution_of_External Humidity.pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

# ('temperature', 'Internal Temperature (°C)'),
#     ('humidity', 'Internal Humidity (%)'),
#     ('extTemp', 'External Temperature (°C)'),
#     ('extHum', 'External Humidity (%)'),
#     ('pressure', 'Pressure (kPa)'),
#     ('V_ch4', 'CH₄ Production Rate (m³/h)')
# palette = ["#4C72B0", "#55A868", "#C44E52",
#            "#8172B2", "#CCB974", "#64B5CD"]
sns.set_theme(
    style="ticks",
    font_scale=1.1
)

col = 'pressure'
label = 'Pressure (kPa)'

plt.figure(figsize=(5.5, 4))

# Violin (distribution)
sns.violinplot(
    y=df_p[col],
    inner=None,
    linewidth=1.2,
    color="#CCB974",
    cut=0,
    density_norm="width",
    alpha=0.85
)

# Boxplot (statistics)
sns.boxplot(
    y=df_p[col],
    width=0.015,
    showcaps=True,
    boxprops=dict(facecolor="#2F2F2F", edgecolor="black"),
    whiskerprops=dict(color="black"),
    medianprops=dict(color="white", linewidth=2),
    showfliers=False
)

plt.ylabel(label)
plt.xlabel("")
plt.title(f"Statistical Distribution of {label}", pad=8)

sns.despine(left=True, bottom=True)
plt.tight_layout()
plt.savefig(
    "Statistical_Distribution_of_Pressure (kPa).pdf",
    bbox_inches="tight",
    format="pdf"
)
plt.show()

# Create test dataframe with timestamps
df_test = df_p.iloc[train_size:].copy()
df_test['V_ch4_pred'] = y_pred_ridge

df_test['V_ch4_actual_smooth'] = df_test['V_ch4'].rolling(
    window=10, center=True, min_periods=1
).mean()

df_test['V_ch4_pred_smooth'] = df_test['V_ch4_pred'].rolling(
    window=10, center=True, min_periods=1
).mean()

plt.style.use("seaborn-v0_8-whitegrid")

fig, ax = plt.subplots(figsize=(12,5))

ax.plot(
    df_test['timestamp'],
    df_test['V_ch4_actual_smooth'],
    color='#1B5E20',
    linewidth=2.5,
    label='Actual CH4 Production'
)

ax.plot(
    df_test['timestamp'],
    df_test['V_ch4_pred_smooth'],
    color='#0D47A1',
    linewidth=2.2,
    label='Predicted CH4 Production'
)

ax.set_xlabel("Time")
ax.set_ylabel("CH4 Production Rate (m³/h)")
ax.set_title(
    "Actual vs Predicted Methane Production Rate of Ridge Regression",
    fontsize=13,
    pad=10
)

ax.legend(frameon=False)
fig.autofmt_xdate()

plt.tight_layout()
plt.savefig(
    "RidgeActual_vs_Predicted_CH4_TimeSeries.pdf",
    dpi=600,
    bbox_inches="tight"
)
plt.show()

